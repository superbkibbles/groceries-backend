package entities

import (
	"errors"
	"time"

	"go.mongodb.org/mongo-driver/bson/primitive"
)

// Category represents a product category in the e-commerce system
type Category struct {
	ID           primitive.ObjectID     `json:"id,omitempty"`
	Name         string                 `json:"name"`               // Legacy field for backward compatibility
	Description  string                 `json:"description"` // Legacy field for backward compatibility
	Slug         string                 `json:"slug"`
	ParentID     primitive.ObjectID     `json:"parent_id,omitempty"`
	Level        int                    `json:"level"`
	Path         []primitive.ObjectID   `json:"path"`
	Translations map[string]Translation `json:"translations"` // Embedded translations
	Children     []Category             `json:"children,omitempty"`
	CreatedAt    time.Time              `json:"created_at"`
	UpdatedAt    time.Time              `json:"updated_at"`
}

// NewCategory creates a new category (ID will be auto-generated by repository)
func NewCategory(name, description, slug string, parentID primitive.ObjectID) *Category {
	now := time.Now()
	level := 1
	path := []primitive.ObjectID{}

	// If this is a subcategory, set level to 2 or more
	if !parentID.IsZero() {
		level = 2 // This will be updated when saved to reflect the actual level
		path = []primitive.ObjectID{parentID}
	}

	return &Category{
		Name:         name,
		Description:  description,
		Slug:         slug,
		ParentID:     parentID,
		Level:        level,
		Path:         path,
		Translations: make(map[string]Translation),
		Children:     []Category{},
		CreatedAt:    now,
		UpdatedAt:    now,
	}
}

// NewCategoryWithTranslations creates a new category with translations
func NewCategoryWithTranslations(slug string, parentID primitive.ObjectID, translations map[string]Translation) *Category {
	now := time.Now()
	level := 1
	path := []primitive.ObjectID{}

	// If this is a subcategory, set level to 2 or more
	if !parentID.IsZero() {
		level = 2 // This will be updated when saved to reflect the actual level
		path = []primitive.ObjectID{parentID}
	}

	// Set legacy fields from English translation if available
	var name, description string
	if enTranslation, exists := translations["en"]; exists {
		name = enTranslation.Name
		description = enTranslation.Description
	}

	return &Category{
		Name:         name,
		Description:  description,
		Slug:         slug,
		ParentID:     parentID,
		Level:        level,
		Path:         path,
		Translations: translations,
		Children:     []Category{},
		CreatedAt:    now,
		UpdatedAt:    now,
	}
}

// AddChild adds a child category to this category
func (c *Category) AddChild(child *Category) error {
	if child == nil {
		return errors.New("child category cannot be nil")
	}

	// Set the parent ID and update level
	child.ParentID = c.ID
	child.Level = c.Level + 1

	// Update the path to include all ancestors
	child.Path = append(append([]primitive.ObjectID{}, c.Path...), c.ID)

	// Add to children collection
	c.Children = append(c.Children, *child)
	c.UpdatedAt = time.Now()

	return nil
}

// Update updates the category details
func (c *Category) Update(name, description, slug string) {
	c.Name = name
	c.Description = description
	c.Slug = slug
	c.UpdatedAt = time.Now()
}

// IsRoot checks if this category is a root category (no parent)
func (c *Category) IsRoot() bool {
	return c.ParentID.IsZero()
}

// IsLeaf checks if this category is a leaf category (no children)
func (c *Category) IsLeaf() bool {
	return len(c.Children) == 0
}

// GetAncestorIDs returns all ancestor IDs including this category's ID
func (c *Category) GetAncestorIDs() []primitive.ObjectID {
	result := append(append([]primitive.ObjectID{}, c.Path...), c.ID)
	return result
}

// ApplyLocalization applies the specified language translation to the category
func (c *Category) ApplyLocalization(language string) {
	if c.Translations == nil {
		c.Translations = make(map[string]Translation)
	}

	// If translation exists for the requested language, use it
	if translation, exists := c.Translations[language]; exists {
		c.Name = translation.Name
		c.Description = translation.Description
		return
	}

	// Fallback to English if available
	if enTranslation, exists := c.Translations["en"]; exists {
		c.Name = enTranslation.Name
		c.Description = enTranslation.Description
	}
}

// AddTranslation adds or updates a translation for a specific language
func (c *Category) AddTranslation(language string, translation Translation) {
	if c.Translations == nil {
		c.Translations = make(map[string]Translation)
	}
	c.Translations[language] = translation

	// Update legacy fields if this is English translation
	if language == "en" {
		c.Name = translation.Name
		c.Description = translation.Description
	}

	c.UpdatedAt = time.Now()
}

// GetTranslation returns the translation for a specific language
func (c *Category) GetTranslation(language string) (Translation, bool) {
	if c.Translations == nil {
		return Translation{}, false
	}
	translation, exists := c.Translations[language]
	return translation, exists
}

// GetAllTranslations returns all translations for the category
func (c *Category) GetAllTranslations() map[string]Translation {
	if c.Translations == nil {
		return make(map[string]Translation)
	}
	return c.Translations
}

// HasTranslation checks if a translation exists for a specific language
func (c *Category) HasTranslation(language string) bool {
	if c.Translations == nil {
		return false
	}
	_, exists := c.Translations[language]
	return exists
}

// GetLocalizedName returns the localized name for the specified language
func (c *Category) GetLocalizedName(language string) string {
	if translation, exists := c.GetTranslation(language); exists {
		return translation.Name
	}

	// Fallback to English
	if translation, exists := c.GetTranslation("en"); exists {
		return translation.Name
	}

	// Fallback to legacy field
	return c.Name
}

// GetLocalizedDescription returns the localized description for the specified language
func (c *Category) GetLocalizedDescription(language string) string {
	if translation, exists := c.GetTranslation(language); exists {
		return translation.Description
	}

	// Fallback to English
	if translation, exists := c.GetTranslation("en"); exists {
		return translation.Description
	}

	// Fallback to legacy field
	return c.Description
}
